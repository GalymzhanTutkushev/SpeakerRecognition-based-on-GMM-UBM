function Frms=GetFrmLst(y,Fs,Y0)
% Вовзвращает список фреймов для вычисления 
% идентификационных характеристик
% y-список крупных блоков, не содержащих пауз
%Frms=zeros(1,3);
Frms=[];
[n,~]=size(y);
%Размер фрейма по умолчанию = 30 мс
N0 = 0.03*Fs;
Nfr = N0;

II=0;
for I=1:n %Цикл по блокам
    Beg = y(I,1);%начало фрейма
    End=Beg+Nfr-1;%конец фрейма
    avgF0 = 0;
    J=0;
    while End<y(I,2)
        Y = Y0(Beg:End);
        Y=Y-mean(Y);
        %вычисляем ЧОТ
        F0_CORR = pitchacorr(Fs, Y);%ч/з АКФ
        F0_CEPS = pitchByCep(Y, Fs);%ч/з кепстр
        %проверяем на соответствие значений ЧОТ, вычисленных
        %разными алгоритмами. Расхождение должно быть не больше 10%.
        if abs(F0_CEPS-F0_CORR)/max(F0_CEPS,F0_CORR) <= 0.1
            F0 = (F0_CEPS+F0_CORR)/2; %сигнал во фрейме вокализован
        else
            F0=0;%сигнал во фрейме не вокализован
        end;
        if F0>0 %если сигнал во фрейме вокализован, то...
            avgF0 = avgF0 + F0;
            J=J+1;
            if J==1
                N1=Beg;
            end;
        else
            if J>1 %если кол-во подряд идущих окон>1
                II=II+1;
                N2 = End;
                Frms(II,1)=N1; %начало фрейма
                Frms(II,2)=N2; %конец фрейма
                Frms(II,3)=avgF0/J;%среднее ЧОТ фрейма
                Frms(II,4)=I; %порядковый номер фрейма
                avgF0 = 0;
                J=0;
            end;
        end;
        Beg=Beg+Nfr;
        End=Beg+Nfr-1;
    end;
    if J>1 %если кол-во подряд идущих окон>1
        II=II+1;
        Frms(II,1)=N1; %начало фрейма
        Frms(II,2)=y(I,2); %конец фрейма
        Frms(II,3)=avgF0/J;%среднее ЧОТ фрейма
        Frms(II,4)=I; %порядковый номер фрейма
    end;
end;